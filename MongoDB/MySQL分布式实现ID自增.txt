
分布式数据库系统中如何实现主键唯一自增

1、最简单的方法

4台数据库，第一台mysql主键从1开始每次加4，第二台从2开始每次加4，以此类推。
需要配置mysql自增起点和mysql自增步长

my.cnf
auto_increment_increment = 5		自增步长
auto_increment_offset = 3			自增起点

改进方案：

　　整体思想：建立两台以上的数据库ID生成服务器，每个服务器都有一张记录各表当前ID的MaxId表，但是MaxId表中Id的增长步长是服务器的数量，起始值依次错开，这样相当于把ID的生成散列到每个服务器节点上。例如：如果我们设置两台数据库ID生成服务器，那么就让一台的MaxId表的Id起始值为1（或当前最大Id+1），每次增长步长为2，另一台的MaxId表的ID起始值为2（或当前最大Id+2），每次步长也为2。这样就将产生ID的压力均匀分散到两台服务器上，同时配合应用程序控制，当一个服务器失效后，系统能自动切换到另一个服务器上获取ID，从而解决的单点问题保证了系统的容错。

　　但是要注意：1、多服务器就必须面临负载均衡的问题；2、倘若添加新节点，需要对原有数据重新根据步长计算迁移数据。

结论：适合大型应用，生成Id较短，友好性比较好。（强烈推荐）

2、搭建sequence server

2.1、选用N台mysql作为sequence server，防止单点故障。
2.2、每个server上的每张表都代表一个序列，每张表也只有一条记录（表级锁，选用myisam引擎）。
2.3、第一台server的序列从1开始每次加N，第二台从2开始每次加N。
2.4、获取时先从第一台server上获取nextVal并修改nextVal加N，如果第一台Server获取失败，则从第二台Server上获取。。

MySQL分布式实现ID自增
由于数据量以及IO效率的因素，很多项目对数据支持的数据库会采取分库分表的方式。使用了分库分表之后需要解决的一个问题就是主键的生成。多个表之间的主键就不能用数据库本身的自增主键来支持，因为不同表之间生成的主键会重复。所以需要其他的方式获取主键ID。

https://www.cnblogs.com/lsx1993/p/4663125.html


一般来说解决方案主要有三种：

1 oracle sequence : 基于第三方oracle的SEQ.NEXTVAL来获取一个ID 优势：简单可用 缺点：需要依赖第三方oracle数据库
2 mysql id区间隔离 : 不同分库设置不同的起始值和步长，比如2台mysql，就可以设置一台只生成奇数，另一台生成偶数. 或者1台用0~10亿，另一台用10~20亿. 优势：利用mysql自增id 缺点：运维成本比较高，数据扩容时需要重新设置步长.
3 基于数据库更新＋内存分配： 在数据库中维护一个ID，获取下一个ID时，会对数据库进行ID=ID+100 WHERE ID=XX，拿到100个ID后，在内存中进行分配 优势：简单高效 缺点：无法保证自增顺序


数据库水平拆分时的方案】
【自增字段分布式方案】
方案一：自增列都有设定步长的特性，假如我们打算把一张表只拆分为两个物理表，那么我们可以在其中一张表里把主键的自增列的步长设计为2，起始值为1，那么它的自增规律就是1,3,5,7依次类推，另外一张物理表的步长我们也可以设置为2，如果起始值为2，那么自增规律就是2,4,6,8以此类推，这样两张表的主键就绝对不会重复了，而且我们也不用另外做两张物理表相应的逻辑关联了。
这种方案还有个潜在的好处，那就是步长的大小和水平数据拆分的粒度关联，也是我们为水平拆分的扩容留有余量，例如我们把步长设计为9，那么理论上水平拆分的物理表可以扩容到9个。
